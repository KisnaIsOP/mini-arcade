-- Mini Arcade Database Schema for Supabase
-- Run this in your Supabase SQL Editor to set up the database

-- Enable Row Level Security
-- This ensures users can only see their own data unless explicitly allowed

-- Create scores table for storing game scores
create table if not exists scores (
  id bigint generated by default as identity primary key,
  game text not null check (game in ('reaction', 'clickspeed', 'aimtrainer', 'memory')),
  username text not null,
  score numeric not null check (score >= 0),
  meta jsonb default '{}',
  created_at timestamptz default now(),
  
  -- Add constraints for data integrity
  constraint valid_username check (length(username) >= 1 and length(username) <= 50),
  constraint valid_game_name check (length(game) >= 1 and length(game) <= 20)
);

-- Create index for faster queries
create index if not exists idx_scores_game_score on scores (game, score desc);
create index if not exists idx_scores_username on scores (username);
create index if not exists idx_scores_created_at on scores (created_at desc);
create index if not exists idx_scores_game_created on scores (game, created_at desc);

-- Enable Row Level Security
alter table scores enable row level security;

-- Create RLS policies

-- Policy: Users can insert their own scores
create policy "Users can insert their own scores" on scores
  for insert
  with check (true); -- Allow anyone to insert scores (for local auth compatibility)

-- Policy: Users can view all scores (for leaderboards)
create policy "Users can view all scores" on scores
  for select
  using (true); -- Allow reading all scores for leaderboards

-- Policy: Users cannot update scores (scores are immutable)
-- No update policy = no updates allowed

-- Policy: Users cannot delete scores (scores are permanent)
-- No delete policy = no deletes allowed

-- Create a view for game leaderboards
create or replace view game_leaderboards as
select 
  game,
  username,
  score,
  meta,
  created_at,
  row_number() over (partition by game order by 
    case 
      when game = 'reaction' then score asc  -- Lower is better for reaction time
      when game = 'memory' then score asc    -- Lower is better for memory time
      else score desc                         -- Higher is better for others
    end
  ) as rank
from scores
order by game, rank;

-- Create a view for recent scores
create or replace view recent_scores as
select 
  game,
  username,
  score,
  meta,
  created_at
from scores
order by created_at desc
limit 100;

-- Create a function to get top scores for a specific game
create or replace function get_top_scores(
  game_name text,
  score_limit integer default 10
)
returns table (
  username text,
  score numeric,
  meta jsonb,
  created_at timestamptz,
  rank bigint
)
language sql
stable
as $$
  select 
    s.username,
    s.score,
    s.meta,
    s.created_at,
    row_number() over (
      order by 
        case 
          when game_name = 'reaction' then s.score asc  -- Lower is better
          when game_name = 'memory' then s.score asc    -- Lower is better
          else s.score desc                              -- Higher is better
        end
    ) as rank
  from scores s
  where s.game = game_name
  order by 
    case 
      when game_name = 'reaction' then s.score asc
      when game_name = 'memory' then s.score asc
      else s.score desc
    end
  limit score_limit;
$$;

-- Create a function to get user's best score for a game
create or replace function get_user_best_score(
  game_name text,
  user_name text
)
returns table (
  score numeric,
  meta jsonb,
  created_at timestamptz
)
language sql
stable
as $$
  select 
    s.score,
    s.meta,
    s.created_at
  from scores s
  where s.game = game_name and s.username = user_name
  order by 
    case 
      when game_name = 'reaction' then s.score asc  -- Lower is better
      when game_name = 'memory' then s.score asc    -- Lower is better  
      else s.score desc                              -- Higher is better
    end
  limit 1;
$$;

-- Create a function to get game statistics
create or replace function get_game_stats(game_name text)
returns json
language sql
stable
as $$
  select json_build_object(
    'total_scores', count(*),
    'unique_players', count(distinct username),
    'best_score', (
      select score from scores 
      where game = game_name 
      order by 
        case 
          when game_name = 'reaction' then score asc
          when game_name = 'memory' then score asc
          else score desc
        end
      limit 1
    ),
    'latest_score', (
      select json_build_object(
        'username', username,
        'score', score,
        'created_at', created_at
      )
      from scores 
      where game = game_name 
      order by created_at desc 
      limit 1
    )
  )
  from scores
  where game = game_name;
$$;

-- Grant permissions to authenticated users
grant usage on schema public to anon, authenticated;
grant all privileges on scores to anon, authenticated;
grant select on game_leaderboards to anon, authenticated;
grant select on recent_scores to anon, authenticated;
grant execute on function get_top_scores(text, integer) to anon, authenticated;
grant execute on function get_user_best_score(text, text) to anon, authenticated;
grant execute on function get_game_stats(text) to anon, authenticated;

-- Insert some sample data for testing (optional)
-- Uncomment these lines to add test data

/*
insert into scores (game, username, score, meta) values
  ('reaction', 'TestPlayer', 245, '{"accuracy": 100}'),
  ('reaction', 'SpeedMaster', 198, '{"accuracy": 100}'),
  ('reaction', 'QuickDraw', 267, '{"accuracy": 100}'),
  ('clickspeed', 'ClickKing', 12.5, '{"clicks": 62}'),
  ('clickspeed', 'FastFingers', 10.8, '{"clicks": 54}'),
  ('aimtrainer', 'Sniper', 85, '{"hits": 45, "accuracy": 85.5}'),
  ('aimtrainer', 'Marksman', 72, '{"hits": 38, "accuracy": 79.2}'),
  ('memory', 'BrainMaster', 28, '{"moves": 16}'),
  ('memory', 'MemoryAce', 34, '{"moves": 22}');
*/

-- Create a simple health check function
create or replace function health_check()
returns json
language sql
as $$
  select json_build_object(
    'status', 'healthy',
    'timestamp', now(),
    'total_scores', (select count(*) from scores),
    'games_available', array['reaction', 'clickspeed', 'aimtrainer', 'memory']
  );
$$;

grant execute on function health_check() to anon, authenticated;

-- Add helpful comments
comment on table scores is 'Stores game scores from Mini Arcade players';
comment on column scores.game is 'Game type: reaction, clickspeed, aimtrainer, or memory';
comment on column scores.username is 'Player username (from local auth or Supabase auth)';
comment on column scores.score is 'Game score (lower is better for reaction/memory, higher for others)';
comment on column scores.meta is 'Additional game metadata (JSON format)';

-- Create a trigger to validate score data
create or replace function validate_score_data()
returns trigger
language plpgsql
as $$
begin
  -- Validate score ranges based on game type
  case new.game
    when 'reaction' then
      if new.score < 50 or new.score > 10000 then
        raise exception 'Invalid reaction time: % (must be 50-10000ms)', new.score;
      end if;
    when 'clickspeed' then
      if new.score < 0 or new.score > 50 then
        raise exception 'Invalid click speed: % (must be 0-50 CPS)', new.score;
      end if;
    when 'aimtrainer' then
      if new.score < 0 or new.score > 1000 then
        raise exception 'Invalid aim score: % (must be 0-1000 points)', new.score;
      end if;
    when 'memory' then
      if new.score < 5 or new.score > 600 then
        raise exception 'Invalid memory time: % (must be 5-600 seconds)', new.score;
      end if;
  end case;
  
  return new;
end;
$$;

create trigger validate_score_trigger
  before insert or update on scores
  for each row execute function validate_score_data();

-- Success message
select 'Mini Arcade database schema created successfully! ðŸŽ®' as message;